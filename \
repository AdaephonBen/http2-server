use std::io::prelude::*;
use std::io::{self, BufReader};
use tokio::prelude::*;
use tokio::{
    net::{TcpListener, TcpStream},
    stream::StreamExt,
};

async fn handle_connection(mut stream: TcpStream) {
    for header in BufReader::new(&mut stream).lines() {
        let header = header.unwrap();
        if header == "\r" {
            break;
        }
    }
    let response = "HTTP/1.1 200 OK\r\n\r\n<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>";
    stream.write(response.as_bytes()).await.unwrap();
    stream.flush();
}

#[tokio::main]
async fn main() {
    let mut listener = TcpListener::bind("127.0.0.1:8078").await.unwrap();
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        match stream {
            Ok(stream) => {
                println!("I am here. ");
                handle_connection(stream).await;
            }
            Err(e) => eprintln!("Error {:?}", e),
        }
    }
}
